<!DOCTYPE html>
<html lang="en">
<head><title>Ray Tracing Demo</title></head>
<body class="flex w-screen h-screen">
<canvas id="canvas" style="background-color: black;"></canvas>

<script>

const W = 300 * 2;
const H = 225 * 2;
const EPS = 1e-8;

/** @type {HTMLCanvasElement} **/
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d')
canvas.width = W;
canvas.height = H;

ctx.fillStyle = 'black'
ctx.fillRect(0, 0, W, H);

const vec3_init = (k) => [k, k, k];
const vec3_mag = (v) => Math.sqrt(v[0] ** 2 + v[1] ** 2 + v[2] ** 2);
const vec3_mag_squared = (v) => v[0] ** 2 + v[1] ** 2 + v[2] ** 2;
const vec3_normalize = (v) => {
    const length = vec3_mag(v);
    return [v[0] / length, v[1] / length, v[2] / length];
}
const vec3_dist = (u, v) => vec3_mag(vec3_sub(u, v));
const vec3_add = (u, v) => [v[0] + u[0], v[1] + u[1], v[2] + u[2]];
const vec3_sub = (u, v) => [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
const vec3_1D_mul = (u, v) => [u[0] * v[0], u[1] * v[1], u[2] * v[2]];
const vec3_scal_add = (v, k) => [v[0] + k, v[1] + k, v[2] + k];
const vec3_scal_mult = (v, k) => [v[0] * k, v[1] * k, v[2] * k];
const vec3_scal_pow = (v, k) => [v[0] ** k, v[1] ** k, v[2] ** k];
const vec3_dot = (u, v) => v[0]*u[0] + v[1]*u[1] + v[2]*u[2];
const vec3_cross = (u, v) => [u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0]];

class Ray {
    constructor(origin, direction){
        this.origin = origin;
        this.direction = direction;
    }
}

const focalLength = -1;
const vertical_field_of_view = Math.PI / 4;
const rayFromCameraPixel = (x, y) => {
    const Hp = -2 * Math.tan(vertical_field_of_view / 2);
	const Wp = Hp * W / H;
    const ray_origin = [
		focalLength * (x / W - 0.5) * Wp,
		focalLength * -(y / H - 0.5) * Hp,
        focalLength
    ];
    const ray_direction = vec3_normalize(ray_origin);
    return new Ray(ray_origin, ray_direction);
}

class Sphere {
	constructor(position, radius, color, reflective, specular = 1){
		this.position = position;
		this.radius = radius;
		this.color = color;
		this.reflective = reflective;
		this.specular = specular;
	}
}
const sphere_array = [
	new Sphere([0, -80, -40], 80, [255, 255, 255], 0.5, 50),
    new Sphere([0, 80, -40], 80, [255, 255, 255], 0.5, 50),

	new Sphere([-6, 0, -13], 3, [255, 255, 255], 0.5, 10),
	new Sphere([6, 0, -13], 3, [255, 255, 255], 0.5, 50),
	new Sphere([0, 0, -20], 3, [255, 255, 255], 0.5, 10),
]

const ray_sphere_intersection = (point, direction, sphere) => {
    const vec_between = vec3_sub(point, sphere.position);
    const a = 1;
    const b = 2 * vec3_dot(direction, vec_between);
    const c = vec3_mag_squared(vec_between) - sphere.radius ** 2;
    if(b**2 - 4*a*c > 0) {
		return (-b - Math.sqrt(b**2 - 4*a*c)) / (2*a);
	}
    else {
		return null;
	}
}

const closest_intersection = (ray) => {
	let closest_t = Infinity;
	let closestSphere = null;

	for(let sphere of sphere_array){
		const new_t = ray_sphere_intersection(ray.origin, ray.direction, sphere);
		if(new_t != null && new_t < closest_t && EPS < new_t){
			closest_t = new_t;
			closestSphere = sphere;
		}
	}

	return [closestSphere, closest_t];
}

const reflect_vector = (direction, normal) => {
	return vec3_sub(vec3_scal_mult(normal, 2 * vec3_dot(direction, normal)), direction);
}

const trace_ray = (ray, depth) => {
	let closest_intersection_output = closest_intersection(ray);
	let [closestSphere, closest_t] = closest_intersection_output;

	if(closestSphere == null) return [0, 0, 0];
	
	const intersection = vec3_add(ray.origin, vec3_scal_mult(ray.direction, closest_t));
	const intersectionNormal = vec3_normalize(vec3_sub(intersection, closestSphere.position));
	const light = compute_lighting(intersection, intersectionNormal, ray, closestSphere.specular);
	const color = vec3_scal_mult(vec3_1D_mul(vec3_normalize(closestSphere.color), vec3_scal_mult(light, 1 / 255)), 400);

	if(depth <= 0 || closestSphere.reflective == 0) return color;

	const reflected_direction = reflect_vector(vec3_scal_mult(ray.direction, -1), intersectionNormal);
	const reflected_color = trace_ray(new Ray(intersection, reflected_direction), depth - 1);

	const baseColorComponent = vec3_scal_mult(color, (1 - closestSphere.reflective));
	const reflectedColorComponent = vec3_scal_mult(reflected_color, closestSphere.reflective);
	return vec3_add(baseColorComponent, reflectedColorComponent);
}

class PointLight {
    constructor(position, power = 10, color = [1, 1, 1]){
        this.position = position;
        this.power = power;
        this.color = vec3_scal_mult(vec3_normalize(color), power);
    }
}

const light_array = [
    new PointLight([-5, 5, 0], 800, [0.1, 0.4, 0.9]),
    new PointLight([5, 5, -10], 800, [0.9, 0.6, 0.1]),
];

const compute_lighting = (point, normal, ray, specular) => {
    let radiance = vec3_init(10); // ambient light

    for(let light of light_array){
        const directionToLight = vec3_sub(light.position, point);
        const effectiveLight = vec3_dot(normal, directionToLight);

        let [blockingSphere, _] = closest_intersection(new Ray(point, vec3_normalize(directionToLight)));

        if(blockingSphere == null && effectiveLight > 0){
			const cosTerm = effectiveLight / (vec3_mag(directionToLight) * vec3_mag(normal));
            const powerFalloff = 1 / (4 * Math.PI * vec3_mag(directionToLight) ** 2);
            const addedRadiance = vec3_scal_mult(light.color, light.power * cosTerm * powerFalloff);
            radiance = vec3_add(radiance, addedRadiance);
		}

        if(specular >= 0){
			const reflected_light_direction = reflect_vector(vec3_scal_mult(directionToLight, -1), normal);
			const effectiveSpecular = vec3_dot(reflected_light_direction, ray.direction);

			if(effectiveSpecular > 0){
				const cosTerm = effectiveSpecular / (vec3_mag(reflected_light_direction) * vec3_mag(ray.direction));
                const powerFalloff = 1 / (4 * Math.PI * vec3_mag(directionToLight) ** 2);
				const addedRadiance = vec3_scal_mult(light.color, light.power * (cosTerm ** specular) * powerFalloff);

				radiance = vec3_add(radiance, addedRadiance);
			}
		}
	}
    return radiance;
}

const imageData = ctx.createImageData(W, H);
const pixels = imageData.data; // [# pixels * 4 channels]

for(let y = 0; y < H; y++){
	for(let x = 0; x < W; x++){
		const i = (y * W + x) * 4;

		const ray = rayFromCameraPixel(x, y);
		const color = trace_ray(ray, 4);
		
		pixels[i] = color[0];		// R
		pixels[i + 1] = color[1];	// G
		pixels[i + 2] = color[2];	// B
		pixels[i + 3] = 255;		// A
	}
}
console.log("DONE")
ctx.putImageData(imageData, 0, 0);

</script>
</body>
</html>
